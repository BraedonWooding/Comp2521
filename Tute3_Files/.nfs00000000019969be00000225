#include <math.h> // we need power
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct BSTNode *BSTree;
typedef struct BSTNode {
  int value;
  BSTree left;
  BSTree right;
  int depth; // how far down the tree
} BSTNode;

typedef struct LLNode *LList;
typedef struct LLNode {
  BSTree node;
  LList next;
} LLNode;

void print_btree(BSTree tree);

int tree_depth(BSTree tree);

// This is just one way of writing this
// You can definitely write this a trillion ways
// NOTE: this is not a balanced insertion
//       meaning the tree isn't going to always be
//       O(log n) search, but its simple to implement
//       so I went for that first :).
BSTree insert(BSTree root, int value) {
  if (root == NULL) {
    BSTree node = malloc(sizeof *node);
    node->left = node->right = NULL;
    node->value = value;
    node->depth = 1;
    return node;
  } else if (value > root->value) {
    // go right
    root->right = insert(root->right, value);
    root->right->depth = root->depth + 1;
  } else if (value < root->value) {
    // go left
    root->left = insert(root->left, value);
    root->left->depth = root->depth + 1;
  }
  return root;
}

int main(int argc, char *argv[]) {
  BSTree tree = NULL;
  for (int i = 1; i < argc; i++) {
    // add to arguments to tree
    if (strlen(argv[i]) > 1) {
      fprintf(stderr, "NOTE: Only works on nodes that are single digit");
      return 1;
    }
    tree = insert(tree, atoi(argv[i]));
  }

  print_btree(tree);

  return 0;
}

int tree_depth(BSTree tree) {
  if (tree == NULL) {
    return 0;
  } else {
    int left = tree_depth(tree->left);
    int right = tree_depth(tree->right);
    return 1 + (left > right ? left : right);
  }
}

// Why are we taking the lists like this?
// Could we also have a container class?  Like last week's lab
void enqueue(LList *first, LList *last, BSTree node) {
  LList new = malloc(sizeof *new);
  new->next = NULL;
  new->node = node;
  if (*first == NULL) {
    *first = *last = new;
  } else {
    // we want to just add it to the end
    (*last)->next = new;
    *last = new;
  }
}

BSTree dequeue(LList *first, LList *last) {
  if (*first == NULL) {
    return NULL;
  }

  LList ret = *first;
  *first = (*first)->next;
  if (*first == NULL) {
    // if that was the last item
    *last = NULL;
  }
  BSTree tree = ret->node;
  free(ret);
  return tree;
}

// NOTE: we are effectively doing what is called a BFS rather than DFS
void print_btree(BSTree tree) {
  if (tree == NULL)
    return;

  // level one by one
  // NOTE: we are doing a queue here
  LList first = NULL;
  LList last = NULL;
  int last_depth = 1;
  int depth = tree_depth(tree);
  int offset = (1 << (depth - 1));

  enqueue(&first, &last, tree);
  while (first != NULL) {
    // while queue not empty
    // grab the first node from queue
    BSTree node = dequeue(&first, &last);

    if (node != NULL && node->depth != last_depth) {
      // new line
      putchar('\n');
      last_depth = node->depth;
      offset = (1 << (depth - last_depth));
    }

    if (node != NULL) {
      for (int i = 0; i < offset; i++) {
        putchar(' ');
      }
      printf("%d", node->value);
      for (int i = 1; i < offset; i++) {
        putchar(' ');
      }
    } else {
      for (int i = 0; i <= (offset - 1) << 1; i++) {
        putchar(' ');
      }
    }

    if (node != NULL) {
      // NOTE: we are happy to add NULL nodes
      //       they make sure we get our spaces right
      enqueue(&first, &last, node->left);
      enqueue(&first, &last, node->right);
    }
  }
  printf("\n");
}
